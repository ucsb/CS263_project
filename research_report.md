## What is a Microservice?

A microservice architecture designs applications as a collection of small autonomous services, each with their own unique functionality. Each of these small modularized services are referred to as a **microservice**. Microservices communicate with each other and work together to create a fully functional multi-feature application.

## What are the Pros and Cons of Microservices?

The independent nature of microservices allow applications to be more efficiently and reliably implemented, and lends well to the agile development model for software teams that do utilize this methodology. Because each microservice performs a specialized task independent from the other, microservices can be added, removed, and updated without interfering with the functionality of other microservices that contribute to the application at large. This means that issues in one microservice may not necessarily cause a failure in the rest of the application (improved fault isolation), and that parts of the application can be upgraded easily. The modularity of the application often leads to increased programmer productivity as well, as code is not only more readable, but developers are also able to pinpoint and resolve issues quickly when testing in smaller units. Developers can also focus on scaling individual components in the application that need to be scaled as opposed to modifying the entirety of the application, and deployment is arguably simpler and faster for these smaller services.

Despite their many advantages, applications designed using microservices can also be difficult to implement because of the need for these microservices to seamlessly communicate with each other. Communication becomes more complicated when considering the asynchronous nature of network communication and experiences with latency. Adding on to that, more services generally means the use of more resources. For example, instead of sharing a database with multiple tables, separate microservices may need to utilize their own database. Contrary to what was mentioned earlier, testing and deploying with microservices can also be more difficult. This is because each service has its own set of logs that require shifting through, and global testing is almost impossible without each microservice being individually tested first. While deployment of a single microservice may be easier, orchastering and coordination among multiple services when deploying is complicated. Because designing a microservice can be difficult, and time consuming some applications are better suited to being designed as microservices than others.

## What Applications are Best Suited to be Written as Microservices?

TODO

## What are Some Tools Used to Develop Microservices? 
### Spring Boot with Spring Cloud
### *Why use Spring Boot with Spring Cloud to Develop Microservices?*

Spring Boot includes libraries with user-friendly APIs that make it easy to deal with many of the difficulties that come with writing Microservices. For example, dealing with partial failures, an issue that arises in many distributed systems of which microservices are not exempt, is made easy with Spring Boot’s fault tolerance library Resilience4J. Resilience4J provides various options to handle partial failures including circuit breakers, retry, timeout, rate limiters, and fallback handlers. Spring Cloud also adopts Eureka, an open source library created by Netflix, which handles service discovery for developers. Eureka uses client-side-discovery, and additionally implements load balancing. The daunting task of microservice communication is also made easy in Spring Boot with libraries such as RestTemplate and WebClient. Some added benefits of Spring Cloud include cloud native support (easy to deploy on Docker and Kuberenetes), as well as libraries to make load balancing and clustering easy. In the microservice we wrote using Spring Cloud, we focused primarily on experimenting with the RestTemplate and Eureka libraries, with a small side investigation into WebClient.

### *Experience With Usage:*

The initial difficulty when developing this application came from not knowing anything about the Spring Boot framework. It was unclear how communication between microservices implemented using Spring Boot should be done, and if this communication should be any different than how a typical client and server model would communicate in Spring Boot. There weren’t many great tutorials on how to get started writing a microservice with Spring Boot, however we were able to find a great [workshop series](https://www.youtube.com/playlist?list=PLqq-6Pq4lTTZSKAFG6aCDVDP86Qx4lNas) on YouTube that provided both conceptual and practical knowledge in regards to implementing a microservice using this framework.

Communication between microservices was concise and easy to implement and was done using RestTemplate. The calls between microservices consisted of a single line of code that included parsing the json payload into an object’s fields for the developer. However, RestTemplate only allows for synchronous programming, which means that a response must be returned from the microservice that is called before the calling microservice can continue. Spring Boot does provide an alternative library, WebClient, that is now preferred over RestTemplate as RestTemplate is no longer supported. Although a bit more verbose, WebClient allows for both asynchronous and synchronous programming and is still simple to use. In our microservices we used WebClient synchronously as making our entire application asynchronous would require reactive programming. We concluded that for those already familiar with Spring Boot, implementing synchronous communication between microservices would take very little time regardless of which library you use.

On another note, while developing our microservice we noticed that we were repeatedly copying and pasting the same model class definitions between our microservices. Creating a shared library with these model class definitions would entirely defeat the purpose of microservices as a change to that library would be seen throughout every microservice that uses that library. As Chris Richardson says in his E-book, Microservices From Design to Deployment, “having a database schema per service is essential if you want to benefit from microservices” (pg. 7). So while we initially thought all this copy and pasting may seem like an inconvenience especially for larger applications, we realized it’s a minor price to pay in comparison to the greater benefits microservices provide.

Using Eureka was arguably the most interesting and enjoyable part of developing our microservice. Eureka handles the issue of service discovery for developers and is incredibly easy to use. First, a Eureka server needs to be created that acts as a service registry which holds all the microservice names and locations that are configured to call this server. In order to create a Eureka server all you need to do is initialize a new Spring Boot project with the Eureka Server library as a dependency. The Eureka Server does need a little bit of configuration to ensure that it doesn’t register itself as a Eureka client, but this configuration consists of a single line of code. Each microservice then needs to be registered as a Eureka client. In order to do this the Eureka client dependency needs to be added to each microservice, each microservice needs to be told where the Eureka server is located (requires only a single line of code), and each microservice needs to identify itself with a name (single line of code). When the microservice is run for the first time it is automatically registered in the service registry. All of this is incredibly simple for the developer, and allows microservices to communicate with other microservices without hardcoding the microservice location. Microservices instead make a call to the Eureka server asking for a microservice by name, the Eureka server then calls the microservice and returns the response to the calling microservice. This means two important things, however. One, the location of the Eureka server should stay fixed, if it changes that means changing a single line of code in all your microservices. Two, the name of a microservice should stay the same, if you wish to change it, that means any microservice that references it needs to be modified to call that service by its new name. In general these don’t seem to be very major issues, and we found these potential cons to be insignificant compared to the ease of use and functionality Eureka provides. As an added bonus, Eureka also handles load balancing on the client side automatically, all done with the simple annotation @Loadbalanced. Finally, once a Eureka client makes a call to the Eureka server for a given service, it doesn’t necessarily need to call the Eureka server again because this location can be cached, which has performance benefits.

In summary, we found that Spring Cloud’s strength when it comes to writing microservices lies in its ability to provide easy to use libraries that abstract away many of the challenges microservices introduce to developers. These libraries allow for increased programmer productivity, and are incredibly easy to use. 

## Flask
### *Why use Flask to Develop Microservices?*
TODO
### *Experience with Usage:*
Using Flask to develop microservices was very easy, and we found lots of great [documentation](https://stackabuse.com/spring-boot-and-flask-microservices-eureka-client/) to do so. However, we did encounter quite a bit of difficulty when it came to using python-eureka-client, a Python library that is meant to replicate Spring Cloud’s Eureka. The Python library is community driven and appears to be maintained by a single developer. We used this library in order to be able to connect the microservice we wrote using Flask to the microservice we wrote using Spring Cloud. Unfortunately, while we were able to make GET requests to our Spring Cloud application there was no documentation on how to make a POST request using python-eureka-client. Looking at the source code for python-eureka-client, we were able to make an attempt at making a POST request, but kept getting the same error. We also found a form post where a user was attempting to make a POST request in the same way, but was running into the same issue. There were no solutions on the form. As a result we had to change the request type we were making to a GET request that acted like a POST request. We found this experience to be a bit unfortunate since making a POST seems like an essential feature. This experience highlighted how even though one of the strengths of microservices is that each service can be implemented in a different language or using a different framework, some tools may not be available in other frameworks or may not be implemented as well, which could cause issues in developing the entirety of the application.

## What are Some Tools Used to Deploy Microservices? 

(Discuss the learning curve of these tools, availability of documentation/community help/support, ease of development and performance for example microservice benchmarks and applications.)

## What are some popular databases used within microservices?
### Spring MongoDB:
### *Why use Spring MongoDB for Microservices?*
TODO
### *Experience With Usage:*
We found Spring MongoDB incredibly easy to use and integrate into our existing Spring Boot microservice application. There was plenty of well written documentation on Spring MongoDB including official documentation from [MongoDB Inc.](https://www.mongodb.com/compatibility/spring-boot) and [blog posts](https://medium.com/javarevisited/building-a-rest-service-with-spring-boot-and-mongodb-part-1-2de01e4f434d.) from community users that we drew heavily from. Integrating Spring MongoDB into our application required adding an additional dependency for Spring MongoDB into our pom.xml, setting up our database, and configuring our microservice to connect to the database. We used MongoDB Atlas to host our cluster in the cloud and generated a connection string for the cluster. Configuring our microservice to connect to a collection in our cluster consisted of adding two lines of code to our application.properties file. One specifying the connection string, and the other specifying the collection. In order to be able to connect to the cluster however, the IP address of the client performing operations on the database needed to be added in the whitelist for Atlas connections. This actually ended up causing some issues later in the development process because our IP address changed and we were unable to connect to the database, but didn’t know why. This was the only downside to our personal experience using Spring MongoDB. However, we did think that this requirement was a great security feature, and lent itself well with the microservice architecture design. This is because, from our understanding of microservices, you’d ideally have a single service or multiple instances of this service that would be responsible for interacting with the database. Thus, the IP address(es) of this service then would be the only one(s) added to the whitelist. Overall, Spring MongoDB, like many of the libraries in Spring Boot, utilizes abstractions and annotations that make integrating and using MongoDB incredibly easy. 